## 컴포넌트는 어떤 기준과 방법으로 분리하는 것이 좋을까?

컴포넌트는 어떤 문맥이든 가장 작은 단위로 언급됩니다. 그래서 우리는 컴포넌트를 어떻게 더 작은 단위로 나누어야 하는지 고민하게 됩니다. 그 과정에서 나온 Presentational Components와 Container Components는 가장 유명한 기준중 하나이고 Atomic Desing의 응용이 사용되기도 합니다.

컴포넌트는 응집도를 높일 수 있는 방향으로 분리하는 것을 고려해봐야한다.

응집도를 나누는 기준은 다음과 같다.

`기능적 응집도` : 모듈이 하나의 기능만 하고 작은 단위로 기능할 때, 단일 책임 원칙과 비슷

`순차적 응집도` : 루틴이 특정 순서로 수행되어야하고 단계마다 정보를 공유하여 동시에 수행되면 완전한 기능을 제공하지 못할 때, 하나의 로직으로 분리하여 하나의 일만 수행하도록 하면 기능적 응집도를 갖게할 수 있다.

`통신적 응집도` : 각 모듈이 같은 데이터를 사용하지만 서로 관련성이 없을 때

`시간적 응집도` : 여러 연산이 동시에 수행되어야 해서 하나의 로직으로 결합될 때

`절차적 응집도` : 특정 순서대로 실행

`논리적 응집도` : 여러 기능을 하나의 루틴에서 수행할 때 ,루틴에 전달되는 조건에 따라 수행하는 기능이 다른 경우

`우연적 응집도` : 놓을 곳을 몰라서 util의 마구 넣어진 경우 (피해야함)

응집도가 낮으면 테스트가 길어지고 사용하기 어려워짐

테스트는 단순히 원하는대로 동작하는 것 뿐 아니라 응집도있는 설계, 사용하기 좋은 코드를 만드는데 도움이 되는 도구로 활용 가능하다!

그래서 우리는 응집도를 높일 수 있도록 컴포넌트를 분리해야한다고 생각합니다.

정확히는 하나의 컴포넌트가 하나의 책임을 지는 단일 책임 원칙을 따라야하고 재사용성을 고려하며 컴포넌트를 분리해야한다.

## 좋은 상태관리란 무엇일까?

좋은 상태관리란 무분별한 전역상태관리를 지양

- 합성 컴포넌트를 적절히 활용하면 Props drilling 해소 가능

상태코드는 연관 컴포넌트와 최대한 가까이 배치하며 (응집성) (State Colocation)

서버의 데이터를 전역상태에 저장할 때는 명확한 전략과 이유를 가지는 것

## 렌더링을 효과적으로 관리하는 방법은 무엇이 있을까?

### 렌더링이란?

현재 props 및 상태를 기반으로 리액트가 컴포넌트에게 UI영역이 어떻게 보이길 원하는지 설명을 요청하는 프로세스.

### 렌더링 프로세스

렌더링 프로세스 동안 리액트는 컴포넌트 트리의 루트에서 시작해 업데이트가 필요하다고 표시된 모든 컴포넌트를 찾기 위해 아래로 순회.

렌더 출력은 일반적으로 JSX구문으로 작성되며 자바스크립트가 컴파일되고 배포를 위해 준비될 때 React.createElement()호출로 변환됩니다. createElement는 의도된 UI 구조를 설명하는 일반 자바스크립트 객체인 React요소를 반환합니다.

Reconciliation(재조정) 현재 가상 DOM 트리를 업데이트된 가상 DOM 트리와 비교하고 가상 DOM을 업데이트된 상태에 맞추는 데 필요한 최소한의 변경 작업을 수행하는 방식으로 작동합니다.

https://medium.com/javarevisited/react-reconciliation-algorithm-86e3e22c1b40

### 렌더링 성능 개선

리액트 컴포넌트의 렌더링 출력은 항상 현재 props 및 현재 컴포넌트 상태에 전적으로 기반해야합니다. 따라서 컴포넌트에 대한 변경이 필요하지 않으면 렌더링 작업을 건너뛸 수 있습니다.

일반적으로 소프트웨어 성능을 향상시키는 두가지 기본 접근 방식은 1) 동일한 작업을 더 빨리 수행하는 것, 2) 더 적게 수행하는 것입니다.

리액트 렌더링을 최적화 하는 것은 주로 렌더링을 적절히 건너뛰어 작업량을 줄이는 것입니다.

### 컴포넌트 렌더링 최적화 기법

리액트는 컴포넌트 렌더링을 생략할 수 있는 세가지 주요한 메서드가 있는데 이는

React.memo, useMemo, useCallback입니다. 하지만 props로 내려주는 모든 함수나 객체에 대해 사용할 필요는 없고 props들이 하위 컴포넌트를 다르게 동작하게 만드는 경우에 한합니다. 메모이제이션 하더라도 props를 비교하는 비용이발생하고 컴포넌트는 항상 새로운 props를 받기 때문에 메모이제이션 체크로는 리렌더링을 막을 수 없습니다.

그렇기 때문에 memo로 최적화하는 것은 컴포넌트가 동일한 props로 리렌더링 하는 경우가 많고, 리렌더링 로직의 비용이 큰 경우에만 가치가 있습니다. 컴포넌트가 리렌더링될 때 지각할 수 있는 지연이 없다면 memo가 필요하지 않습니다.

https://velog.io/@superlipbalm/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior

## Props Drilling이란 무엇이고 이를 어떻게 해결할 수 있는가?

props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 여러 컴포넌트를 넘기면서 마치 드릴로 땅을 뚫는 것 같다해서 붙여진 이름. props 전달이 3~ 5개 정도라면 큰 문제가 되지 않음 하지만 10개 이상의 props라면 해당 props를 추적하기 어려워지고 그에 따라 유지보수도 어려워진다.

### 해결방법

1. 전역상태관리 사용

컴포넌트들의 의존성을 분리할 수 있음 하지만 이로 인해 발생하는 성능 저하나 공유하지 않아도 될 컴포넌트에도 상태를 공유하게 됨

1. children 사용

하나의 컴포넌트에서 값을 관리하고 그 값을 하위요소로 전달할 수 있음
